{
    "sourceFile": "components/trip/CityCountrySearch.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 48,
            "patches": [
                {
                    "date": 1752500032569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752500048013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,9 +99,9 @@\n \r\n     const request: google.maps.places.AutocompletionRequest = {\r\n       input: value,\r\n       types: ['(cities)'], // Focus on cities and administrative areas\r\n-      componentRestrictions: {}, // No country restrictions - allow worldwide search\r\n+      // No componentRestrictions - allow worldwide search\r\n     };\r\n \r\n     autocompleteService.current.getPlacePredictions(request, (predictions, status) => {\r\n       setIsLoading(false);\r\n"
                },
                {
                    "date": 1752500464262,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,8 +23,9 @@\n   \r\n   const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n+  const isSettingFromSelection = useRef(false);\r\n \r\n   // Update local state when value prop changes\r\n   useEffect(() => {\r\n     setSearchValue(value);\r\n"
                },
                {
                    "date": 1752500476133,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,8 +77,14 @@\n \r\n   // Handle search with debouncing\r\n   useEffect(() => {\r\n     const timeoutId = setTimeout(() => {\r\n+      // Don't search if we're setting the value from a selection\r\n+      if (isSettingFromSelection.current) {\r\n+        isSettingFromSelection.current = false;\r\n+        return;\r\n+      }\r\n+      \r\n       if (searchValue.trim() && autocompleteService.current) {\r\n         handleSearch(searchValue.trim());\r\n       } else {\r\n         setPredictions([]);\r\n"
                },
                {
                    "date": 1752500486724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -149,8 +149,11 @@\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ Selected location:', selectedLocation);\r\n     \r\n+    // Set flag to prevent search when setting value from selection\r\n+    isSettingFromSelection.current = true;\r\n+    \r\n     setSearchValue(selectedLocation);\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n     setSelectedIndex(-1);\r\n"
                },
                {
                    "date": 1752500603511,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,13 +19,13 @@\n   const [predictions, setPredictions] = useState<google.maps.places.AutocompletePrediction[]>([]);\r\n   const [isLoading, setIsLoading] = useState(false);\r\n   const [showSuggestions, setShowSuggestions] = useState(false);\r\n   const [selectedIndex, setSelectedIndex] = useState(-1);\r\n+  const [justSelected, setJustSelected] = useState(false);\r\n   \r\n   const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n-  const isSettingFromSelection = useRef(false);\r\n \r\n   // Update local state when value prop changes\r\n   useEffect(() => {\r\n     setSearchValue(value);\r\n"
                },
                {
                    "date": 1752500618451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,11 +77,11 @@\n \r\n   // Handle search with debouncing\r\n   useEffect(() => {\r\n     const timeoutId = setTimeout(() => {\r\n-      // Don't search if we're setting the value from a selection\r\n-      if (isSettingFromSelection.current) {\r\n-        isSettingFromSelection.current = false;\r\n+      // Don't search if we just selected something\r\n+      if (justSelected) {\r\n+        setJustSelected(false);\r\n         return;\r\n       }\r\n       \r\n       if (searchValue.trim() && autocompleteService.current) {\r\n@@ -92,9 +92,9 @@\n       }\r\n     }, 300);\r\n \r\n     return () => clearTimeout(timeoutId);\r\n-  }, [searchValue]);\r\n+  }, [searchValue, justSelected]);\r\n \r\n   const handleSearch = (value: string) => {\r\n     if (!autocompleteService.current) {\r\n       console.warn('‚ö†Ô∏è Autocomplete service not initialized');\r\n"
                },
                {
                    "date": 1752500631039,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -150,9 +150,9 @@\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ Selected location:', selectedLocation);\r\n     \r\n     // Set flag to prevent search when setting value from selection\r\n-    isSettingFromSelection.current = true;\r\n+    setJustSelected(true);\r\n     \r\n     setSearchValue(selectedLocation);\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n"
                },
                {
                    "date": 1752500644522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,8 +139,13 @@\n   const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n     const value = e.target.value;\r\n     setSearchValue(value);\r\n     \r\n+    // Reset the \"just selected\" flag when user types manually\r\n+    if (justSelected) {\r\n+      setJustSelected(false);\r\n+    }\r\n+    \r\n     if (!value.trim()) {\r\n       setPredictions([]);\r\n       setShowSuggestions(false);\r\n     }\r\n"
                },
                {
                    "date": 1752500861418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,13 +19,13 @@\n   const [predictions, setPredictions] = useState<google.maps.places.AutocompletePrediction[]>([]);\r\n   const [isLoading, setIsLoading] = useState(false);\r\n   const [showSuggestions, setShowSuggestions] = useState(false);\r\n   const [selectedIndex, setSelectedIndex] = useState(-1);\r\n-  const [justSelected, setJustSelected] = useState(false);\r\n   \r\n   const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n+  const lastSelectedValue = useRef<string>('');\r\n \r\n   // Update local state when value prop changes\r\n   useEffect(() => {\r\n     setSearchValue(value);\r\n"
                },
                {
                    "date": 1752500873114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,11 +77,11 @@\n \r\n   // Handle search with debouncing\r\n   useEffect(() => {\r\n     const timeoutId = setTimeout(() => {\r\n-      // Don't search if we just selected something\r\n-      if (justSelected) {\r\n-        setJustSelected(false);\r\n+      // Don't search if the current value is exactly what we just selected\r\n+      if (searchValue === lastSelectedValue.current) {\r\n+        console.log('üö´ Skipping search - value matches last selection:', searchValue);\r\n         return;\r\n       }\r\n       \r\n       if (searchValue.trim() && autocompleteService.current) {\r\n@@ -92,9 +92,9 @@\n       }\r\n     }, 300);\r\n \r\n     return () => clearTimeout(timeoutId);\r\n-  }, [searchValue, justSelected]);\r\n+  }, [searchValue]);\r\n \r\n   const handleSearch = (value: string) => {\r\n     if (!autocompleteService.current) {\r\n       console.warn('‚ö†Ô∏è Autocomplete service not initialized');\r\n"
                },
                {
                    "date": 1752500880703,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,11 +139,11 @@\n   const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n     const value = e.target.value;\r\n     setSearchValue(value);\r\n     \r\n-    // Reset the \"just selected\" flag when user types manually\r\n-    if (justSelected) {\r\n-      setJustSelected(false);\r\n+    // Clear the last selected value when user types manually (not from selection)\r\n+    if (value !== lastSelectedValue.current) {\r\n+      lastSelectedValue.current = '';\r\n     }\r\n     \r\n     if (!value.trim()) {\r\n       setPredictions([]);\r\n"
                },
                {
                    "date": 1752500890036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,10 +154,10 @@\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ Selected location:', selectedLocation);\r\n     \r\n-    // Set flag to prevent search when setting value from selection\r\n-    setJustSelected(true);\r\n+    // Store the selected value to prevent searching for it again\r\n+    lastSelectedValue.current = selectedLocation;\r\n     \r\n     setSearchValue(selectedLocation);\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n"
                },
                {
                    "date": 1752501117320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,15 +154,18 @@\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ Selected location:', selectedLocation);\r\n     \r\n+    // Immediately hide suggestions and clear predictions to prevent re-searching\r\n+    setShowSuggestions(false);\r\n+    setPredictions([]);\r\n+    setSelectedIndex(-1);\r\n+    \r\n     // Store the selected value to prevent searching for it again\r\n     lastSelectedValue.current = selectedLocation;\r\n     \r\n+    // Set the value after storing it in the ref\r\n     setSearchValue(selectedLocation);\r\n-    setShowSuggestions(false);\r\n-    setPredictions([]);\r\n-    setSelectedIndex(-1);\r\n     \r\n     onLocationSelect(selectedLocation);\r\n   };\r\n \r\n"
                },
                {
                    "date": 1752501140839,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,8 +166,15 @@\n     // Set the value after storing it in the ref\r\n     setSearchValue(selectedLocation);\r\n     \r\n     onLocationSelect(selectedLocation);\r\n+    \r\n+    // Clear the lastSelectedValue after a delay to allow normal searches again\r\n+    setTimeout(() => {\r\n+      if (searchValue === selectedLocation) {\r\n+        lastSelectedValue.current = '';\r\n+      }\r\n+    }, 1000);\r\n   };\r\n \r\n   const handleKeyDown = (e: React.KeyboardEvent) => {\r\n     if (!showSuggestions || predictions.length === 0) return;\r\n"
                },
                {
                    "date": 1752501163888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,27 +154,21 @@\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ Selected location:', selectedLocation);\r\n     \r\n-    // Immediately hide suggestions and clear predictions to prevent re-searching\r\n+    // Follow the same pattern as LocationSearch - hide suggestions first\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n     setSelectedIndex(-1);\r\n     \r\n-    // Store the selected value to prevent searching for it again\r\n-    lastSelectedValue.current = selectedLocation;\r\n-    \r\n-    // Set the value after storing it in the ref\r\n+    // Set the value (this is what the user sees)\r\n     setSearchValue(selectedLocation);\r\n     \r\n+    // Call the selection handler\r\n     onLocationSelect(selectedLocation);\r\n     \r\n-    // Clear the lastSelectedValue after a delay to allow normal searches again\r\n-    setTimeout(() => {\r\n-      if (searchValue === selectedLocation) {\r\n-        lastSelectedValue.current = '';\r\n-      }\r\n-    }, 1000);\r\n+    // Store this value as the last selected to prevent immediate re-search\r\n+    lastSelectedValue.current = selectedLocation;\r\n   };\r\n \r\n   const handleKeyDown = (e: React.KeyboardEvent) => {\r\n     if (!showSuggestions || predictions.length === 0) return;\r\n"
                },
                {
                    "date": 1752501184575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,21 +154,21 @@\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ Selected location:', selectedLocation);\r\n     \r\n+    // CRITICAL: Set the lastSelectedValue BEFORE setting searchValue to prevent race condition\r\n+    lastSelectedValue.current = selectedLocation;\r\n+    \r\n     // Follow the same pattern as LocationSearch - hide suggestions first\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n     setSelectedIndex(-1);\r\n     \r\n-    // Set the value (this is what the user sees)\r\n+    // Set the value (this is what the user sees) - this will trigger the search effect\r\n     setSearchValue(selectedLocation);\r\n     \r\n     // Call the selection handler\r\n     onLocationSelect(selectedLocation);\r\n-    \r\n-    // Store this value as the last selected to prevent immediate re-search\r\n-    lastSelectedValue.current = selectedLocation;\r\n   };\r\n \r\n   const handleKeyDown = (e: React.KeyboardEvent) => {\r\n     if (!showSuggestions || predictions.length === 0) return;\r\n"
                },
                {
                    "date": 1752501203218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,16 +76,23 @@\n   }, []);\r\n \r\n   // Handle search with debouncing\r\n   useEffect(() => {\r\n+    console.log('üîç Search effect triggered:', { \r\n+      searchValue, \r\n+      lastSelected: lastSelectedValue.current,\r\n+      willSkip: searchValue === lastSelectedValue.current \r\n+    });\r\n+    \r\n     const timeoutId = setTimeout(() => {\r\n       // Don't search if the current value is exactly what we just selected\r\n       if (searchValue === lastSelectedValue.current) {\r\n         console.log('üö´ Skipping search - value matches last selection:', searchValue);\r\n         return;\r\n       }\r\n       \r\n       if (searchValue.trim() && autocompleteService.current) {\r\n+        console.log('üîç Executing search for:', searchValue.trim());\r\n         handleSearch(searchValue.trim());\r\n       } else {\r\n         setPredictions([]);\r\n         setShowSuggestions(false);\r\n"
                },
                {
                    "date": 1752501331856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n   \r\n   const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n-  const lastSelectedValue = useRef<string>('');\r\n+  const searchTimeout = useRef<NodeJS.Timeout | null>(null);\r\n \r\n   // Update local state when value prop changes\r\n   useEffect(() => {\r\n     setSearchValue(value);\r\n"
                },
                {
                    "date": 1752501346719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,21 +76,16 @@\n   }, []);\r\n \r\n   // Handle search with debouncing\r\n   useEffect(() => {\r\n-    console.log('üîç Search effect triggered:', { \r\n-      searchValue, \r\n-      lastSelected: lastSelectedValue.current,\r\n-      willSkip: searchValue === lastSelectedValue.current \r\n-    });\r\n+    console.log('üîç Search effect triggered for:', searchValue);\r\n     \r\n-    const timeoutId = setTimeout(() => {\r\n-      // Don't search if the current value is exactly what we just selected\r\n-      if (searchValue === lastSelectedValue.current) {\r\n-        console.log('üö´ Skipping search - value matches last selection:', searchValue);\r\n-        return;\r\n-      }\r\n-      \r\n+    // Clear any existing timeout\r\n+    if (searchTimeout.current) {\r\n+      clearTimeout(searchTimeout.current);\r\n+    }\r\n+    \r\n+    searchTimeout.current = setTimeout(() => {\r\n       if (searchValue.trim() && autocompleteService.current) {\r\n         console.log('üîç Executing search for:', searchValue.trim());\r\n         handleSearch(searchValue.trim());\r\n       } else {\r\n@@ -98,9 +93,13 @@\n         setShowSuggestions(false);\r\n       }\r\n     }, 300);\r\n \r\n-    return () => clearTimeout(timeoutId);\r\n+    return () => {\r\n+      if (searchTimeout.current) {\r\n+        clearTimeout(searchTimeout.current);\r\n+      }\r\n+    };\r\n   }, [searchValue]);\r\n \r\n   const handleSearch = (value: string) => {\r\n     if (!autocompleteService.current) {\r\n"
                },
                {
                    "date": 1752501358552,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,13 +145,8 @@\n   const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n     const value = e.target.value;\r\n     setSearchValue(value);\r\n     \r\n-    // Clear the last selected value when user types manually (not from selection)\r\n-    if (value !== lastSelectedValue.current) {\r\n-      lastSelectedValue.current = '';\r\n-    }\r\n-    \r\n     if (!value.trim()) {\r\n       setPredictions([]);\r\n       setShowSuggestions(false);\r\n     }\r\n"
                },
                {
                    "date": 1752501371485,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,10 +155,14 @@\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ Selected location:', selectedLocation);\r\n     \r\n-    // CRITICAL: Set the lastSelectedValue BEFORE setting searchValue to prevent race condition\r\n-    lastSelectedValue.current = selectedLocation;\r\n+    // CRITICAL: Cancel any pending search immediately\r\n+    if (searchTimeout.current) {\r\n+      clearTimeout(searchTimeout.current);\r\n+      searchTimeout.current = null;\r\n+      console.log('üö´ Cancelled pending search timeout');\r\n+    }\r\n     \r\n     // Follow the same pattern as LocationSearch - hide suggestions first\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n"
                },
                {
                    "date": 1752501387891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,8 +24,9 @@\n   const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n   const searchTimeout = useRef<NodeJS.Timeout | null>(null);\r\n+  const preventNextSearch = useRef(false);\r\n \r\n   // Update local state when value prop changes\r\n   useEffect(() => {\r\n     setSearchValue(value);\r\n"
                },
                {
                    "date": 1752501402551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,8 +85,15 @@\n       clearTimeout(searchTimeout.current);\r\n     }\r\n     \r\n     searchTimeout.current = setTimeout(() => {\r\n+      // Check if we should prevent this search (just made a selection)\r\n+      if (preventNextSearch.current) {\r\n+        console.log('üö´ Preventing search after selection');\r\n+        preventNextSearch.current = false;\r\n+        return;\r\n+      }\r\n+      \r\n       if (searchValue.trim() && autocompleteService.current) {\r\n         console.log('üîç Executing search for:', searchValue.trim());\r\n         handleSearch(searchValue.trim());\r\n       } else {\r\n"
                },
                {
                    "date": 1752501418433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,8 +170,12 @@\n       searchTimeout.current = null;\r\n       console.log('üö´ Cancelled pending search timeout');\r\n     }\r\n     \r\n+    // Set flag to prevent the next search (since we're about to set the value)\r\n+    preventNextSearch.current = true;\r\n+    console.log('üö´ Set flag to prevent next search');\r\n+    \r\n     // Follow the same pattern as LocationSearch - hide suggestions first\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n     setSelectedIndex(-1);\r\n"
                },
                {
                    "date": 1752501553443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,13 +20,14 @@\n   const [isLoading, setIsLoading] = useState(false);\r\n   const [showSuggestions, setShowSuggestions] = useState(false);\r\n   const [selectedIndex, setSelectedIndex] = useState(-1);\r\n   \r\n-  const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n+  const autocompleteSuggestion = useRef<google.maps.places.AutocompleteSuggestion | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n   const searchTimeout = useRef<NodeJS.Timeout | null>(null);\r\n   const preventNextSearch = useRef(false);\r\n+  const lastSelectedValue = useRef<string>('');\r\n \r\n   // Update local state when value prop changes\r\n   useEffect(() => {\r\n     setSearchValue(value);\r\n"
                },
                {
                    "date": 1752501563484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,9 @@\n     };\r\n \r\n     const setupServices = () => {\r\n       if (window.google?.maps?.places) {\r\n-        autocompleteService.current = new google.maps.places.AutocompleteService();\r\n+        autocompleteSuggestion.current = new google.maps.places.AutocompleteSuggestion();\r\n         console.log('‚úÖ City/Country autocomplete service initialized');\r\n       }\r\n     };\r\n \r\n"
                },
                {
                    "date": 1752501575837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,9 +93,15 @@\n         preventNextSearch.current = false;\r\n         return;\r\n       }\r\n       \r\n-      if (searchValue.trim() && autocompleteService.current) {\r\n+      // Check if this is the same value we just selected\r\n+      if (searchValue.trim() === lastSelectedValue.current) {\r\n+        console.log('üö´ Skipping search - same as last selected value');\r\n+        return;\r\n+      }\r\n+      \r\n+      if (searchValue.trim() && autocompleteSuggestion.current) {\r\n         console.log('üîç Executing search for:', searchValue.trim());\r\n         handleSearch(searchValue.trim());\r\n       } else {\r\n         setPredictions([]);\r\n"
                },
                {
                    "date": 1752501591964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,10 +115,10 @@\n       }\r\n     };\r\n   }, [searchValue]);\r\n \r\n-  const handleSearch = (value: string) => {\r\n-    if (!autocompleteService.current) {\r\n+  const handleSearch = async (value: string) => {\r\n+    if (!autocompleteSuggestion.current) {\r\n       console.warn('‚ö†Ô∏è Autocomplete service not initialized');\r\n       return;\r\n     }\r\n \r\n@@ -130,16 +130,17 @@\n       types: ['(cities)'], // Focus on cities and administrative areas\r\n       // No componentRestrictions - allow worldwide search\r\n     };\r\n \r\n-    autocompleteService.current.getPlacePredictions(request, (predictions, status) => {\r\n+    try {\r\n+      const response = await autocompleteSuggestion.current.fetchPredictions(request);\r\n       setIsLoading(false);\r\n       \r\n-      if (status === google.maps.places.PlacesServiceStatus.OK && predictions) {\r\n-        console.log('‚úÖ Found predictions:', predictions.length);\r\n+      if (response.predictions && response.predictions.length > 0) {\r\n+        console.log('‚úÖ Found predictions:', response.predictions.length);\r\n         \r\n         // Filter and sort predictions to prioritize cities and countries\r\n-        const filteredPredictions = predictions.filter(prediction => {\r\n+        const filteredPredictions = response.predictions.filter(prediction => {\r\n           const types = prediction.types || [];\r\n           return types.includes('locality') || \r\n                  types.includes('administrative_area_level_1') || \r\n                  types.includes('country') ||\r\n@@ -149,13 +150,18 @@\n         setPredictions(filteredPredictions.slice(0, 5)); // Limit to 5 suggestions\r\n         setShowSuggestions(true);\r\n         setSelectedIndex(-1);\r\n       } else {\r\n-        console.log('‚ùå No predictions found or error:', status);\r\n+        console.log('‚ùå No predictions found');\r\n         setPredictions([]);\r\n         setShowSuggestions(false);\r\n       }\r\n-    });\r\n+    } catch (error) {\r\n+      setIsLoading(false);\r\n+      console.error('‚ùå Error fetching predictions:', error);\r\n+      setPredictions([]);\r\n+      setShowSuggestions(false);\r\n+    }\r\n   };\r\n \r\n   const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n     const value = e.target.value;\r\n"
                },
                {
                    "date": 1752501666851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,9 +131,10 @@\n       // No componentRestrictions - allow worldwide search\r\n     };\r\n \r\n     try {\r\n-      const response = await autocompleteSuggestion.current.fetchPredictions(request);\r\n+      // Use getPlacePredictions without callback to get a promise\r\n+      const response = await autocompleteSuggestion.current.getPlacePredictions(request);\r\n       setIsLoading(false);\r\n       \r\n       if (response.predictions && response.predictions.length > 0) {\r\n         console.log('‚úÖ Found predictions:', response.predictions.length);\r\n"
                },
                {
                    "date": 1752501674313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n   const [isLoading, setIsLoading] = useState(false);\r\n   const [showSuggestions, setShowSuggestions] = useState(false);\r\n   const [selectedIndex, setSelectedIndex] = useState(-1);\r\n   \r\n-  const autocompleteSuggestion = useRef<google.maps.places.AutocompleteSuggestion | null>(null);\r\n+  const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n   const searchTimeout = useRef<NodeJS.Timeout | null>(null);\r\n   const preventNextSearch = useRef(false);\r\n"
                },
                {
                    "date": 1752501684825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,9 @@\n     };\r\n \r\n     const setupServices = () => {\r\n       if (window.google?.maps?.places) {\r\n-        autocompleteSuggestion.current = new google.maps.places.AutocompleteSuggestion();\r\n+        autocompleteService.current = new google.maps.places.AutocompleteService();\r\n         console.log('‚úÖ City/Country autocomplete service initialized');\r\n       }\r\n     };\r\n \r\n"
                },
                {
                    "date": 1752501695558,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,9 +99,9 @@\n         console.log('üö´ Skipping search - same as last selected value');\r\n         return;\r\n       }\r\n       \r\n-      if (searchValue.trim() && autocompleteSuggestion.current) {\r\n+      if (searchValue.trim() && autocompleteService.current) {\r\n         console.log('üîç Executing search for:', searchValue.trim());\r\n         handleSearch(searchValue.trim());\r\n       } else {\r\n         setPredictions([]);\r\n"
                },
                {
                    "date": 1752501710372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n     };\r\n   }, [searchValue]);\r\n \r\n   const handleSearch = async (value: string) => {\r\n-    if (!autocompleteSuggestion.current) {\r\n+    if (!autocompleteService.current) {\r\n       console.warn('‚ö†Ô∏è Autocomplete service not initialized');\r\n       return;\r\n     }\r\n \r\n@@ -132,16 +132,16 @@\n     };\r\n \r\n     try {\r\n       // Use getPlacePredictions without callback to get a promise\r\n-      const response = await autocompleteSuggestion.current.getPlacePredictions(request);\r\n+      const response = await autocompleteService.current.getPlacePredictions(request);\r\n       setIsLoading(false);\r\n       \r\n       if (response.predictions && response.predictions.length > 0) {\r\n         console.log('‚úÖ Found predictions:', response.predictions.length);\r\n         \r\n         // Filter and sort predictions to prioritize cities and countries\r\n-        const filteredPredictions = response.predictions.filter(prediction => {\r\n+        const filteredPredictions = response.predictions.filter((prediction: google.maps.places.AutocompletePrediction) => {\r\n           const types = prediction.types || [];\r\n           return types.includes('locality') || \r\n                  types.includes('administrative_area_level_1') || \r\n                  types.includes('country') ||\r\n"
                },
                {
                    "date": 1752501725548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -188,8 +188,12 @@\n     // Set flag to prevent the next search (since we're about to set the value)\r\n     preventNextSearch.current = true;\r\n     console.log('üö´ Set flag to prevent next search');\r\n     \r\n+    // Store the selected value to prevent re-searching\r\n+    lastSelectedValue.current = selectedLocation;\r\n+    console.log('üíæ Stored selected value:', selectedLocation);\r\n+    \r\n     // Follow the same pattern as LocationSearch - hide suggestions first\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n     setSelectedIndex(-1);\r\n"
                },
                {
                    "date": 1752501735442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,8 +167,14 @@\n   const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n     const value = e.target.value;\r\n     setSearchValue(value);\r\n     \r\n+    // Clear the last selected value when user starts typing something new\r\n+    if (lastSelectedValue.current && value !== lastSelectedValue.current) {\r\n+      lastSelectedValue.current = '';\r\n+      console.log('üóëÔ∏è Cleared last selected value - user is typing new input');\r\n+    }\r\n+    \r\n     if (!value.trim()) {\r\n       setPredictions([]);\r\n       setShowSuggestions(false);\r\n     }\r\n"
                },
                {
                    "date": 1752502012380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,15 @@\n 'use client';\r\n \r\n-import { useState, useEffect, useRef } from 'react';\r\n+import React, { useState, useRef, useEffect } from 'react';\r\n+import { ChevronDownIcon } from '@heroicons/react/20/solid';\r\n \r\n+declare global {\r\n+  interface Window {\r\n+    google: any;\r\n+  }\r\n+}\r\n+\r\n interface CityCountrySearchProps {\r\n   onLocationSelect: (location: string) => void;\r\n   value: string;\r\n   placeholder?: string;\r\n@@ -24,40 +31,22 @@\n   const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n   const searchTimeout = useRef<NodeJS.Timeout | null>(null);\r\n-  const preventNextSearch = useRef(false);\r\n   const lastSelectedValue = useRef<string>('');\r\n+  const isSelecting = useRef<boolean>(false);\r\n \r\n-  // Update local state when value prop changes\r\n+  // Initialize Google Places service\r\n   useEffect(() => {\r\n-    setSearchValue(value);\r\n-  }, [value]);\r\n-\r\n-  // Initialize Google Places services\r\n-  useEffect(() => {\r\n     const initializeServices = async () => {\r\n-      // Check if Google Maps is already loaded\r\n       if (!window.google?.maps?.places) {\r\n-        // Load Google Maps if not already loaded\r\n-        const apiKey = process.env.NEXT_PUBLIC_GOOGLE_PLACES_API_KEY || process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;\r\n-        if (!apiKey) {\r\n-          console.error('‚ùå Google Places API key not found');\r\n-          return;\r\n-        }\r\n-\r\n-        console.log('üìç Loading Google Maps with Places API for city/country search...');\r\n-\r\n+        // Load Google Places API if not already loaded\r\n         const script = document.createElement('script');\r\n-        script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places`;\r\n+        script.src = `https://maps.googleapis.com/maps/api/js?key=${process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}&libraries=places`;\r\n         script.async = true;\r\n-        script.defer = true;\r\n-        \r\n         script.onload = () => {\r\n-          console.log('‚úÖ Google Places API loaded successfully');\r\n           setupServices();\r\n         };\r\n-        \r\n         script.onerror = () => {\r\n           console.error('‚ùå Failed to load Google Places API');\r\n         };\r\n         \r\n@@ -76,33 +65,30 @@\n \r\n     initializeServices();\r\n   }, []);\r\n \r\n-  // Handle search with debouncing\r\n+  // Handle search with debouncing and proper prevention logic\r\n   useEffect(() => {\r\n-    console.log('üîç Search effect triggered for:', searchValue);\r\n-    \r\n     // Clear any existing timeout\r\n     if (searchTimeout.current) {\r\n       clearTimeout(searchTimeout.current);\r\n     }\r\n-    \r\n+\r\n+    // Don't search if we're in the middle of a selection\r\n+    if (isSelecting.current) {\r\n+      console.log('üö´ Skipping search - selection in progress');\r\n+      return;\r\n+    }\r\n+\r\n+    // Don't search if this is the same value we just selected\r\n+    if (searchValue === lastSelectedValue.current) {\r\n+      console.log('üö´ Skipping search - same as last selected value:', searchValue);\r\n+      return;\r\n+    }\r\n+\r\n     searchTimeout.current = setTimeout(() => {\r\n-      // Check if we should prevent this search (just made a selection)\r\n-      if (preventNextSearch.current) {\r\n-        console.log('üö´ Preventing search after selection');\r\n-        preventNextSearch.current = false;\r\n-        return;\r\n-      }\r\n-      \r\n-      // Check if this is the same value we just selected\r\n-      if (searchValue.trim() === lastSelectedValue.current) {\r\n-        console.log('üö´ Skipping search - same as last selected value');\r\n-        return;\r\n-      }\r\n-      \r\n       if (searchValue.trim() && autocompleteService.current) {\r\n-        console.log('üîç Executing search for:', searchValue.trim());\r\n+        console.log('üîç Searching for cities/countries:', searchValue.trim());\r\n         handleSearch(searchValue.trim());\r\n       } else {\r\n         setPredictions([]);\r\n         setShowSuggestions(false);\r\n@@ -122,22 +108,29 @@\n       return;\r\n     }\r\n \r\n     setIsLoading(true);\r\n-    console.log('üîç Searching for cities/countries:', value);\r\n \r\n     const request: google.maps.places.AutocompletionRequest = {\r\n       input: value,\r\n       types: ['(cities)'], // Focus on cities and administrative areas\r\n       // No componentRestrictions - allow worldwide search\r\n     };\r\n \r\n     try {\r\n-      // Use getPlacePredictions without callback to get a promise\r\n-      const response = await autocompleteService.current.getPlacePredictions(request);\r\n+      // Use the promise-based approach to avoid the callback deprecation warning\r\n+      const response = await new Promise<{\r\n+        predictions: google.maps.places.AutocompletePrediction[];\r\n+        status: google.maps.places.PlacesServiceStatus;\r\n+      }>((resolve) => {\r\n+        autocompleteService.current!.getPlacePredictions(request, (predictions, status) => {\r\n+          resolve({ predictions: predictions || [], status });\r\n+        });\r\n+      });\r\n+\r\n       setIsLoading(false);\r\n       \r\n-      if (response.predictions && response.predictions.length > 0) {\r\n+      if (response.status === google.maps.places.PlacesServiceStatus.OK && response.predictions.length > 0) {\r\n         console.log('‚úÖ Found predictions:', response.predictions.length);\r\n         \r\n         // Filter and sort predictions to prioritize cities and countries\r\n         const filteredPredictions = response.predictions.filter((prediction: google.maps.places.AutocompletePrediction) => {\r\n@@ -183,37 +176,40 @@\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ Selected location:', selectedLocation);\r\n     \r\n-    // CRITICAL: Cancel any pending search immediately\r\n+    // Set the selection flag to prevent any searches\r\n+    isSelecting.current = true;\r\n+    \r\n+    // Cancel any pending search\r\n     if (searchTimeout.current) {\r\n       clearTimeout(searchTimeout.current);\r\n       searchTimeout.current = null;\r\n-      console.log('üö´ Cancelled pending search timeout');\r\n     }\r\n     \r\n-    // Set flag to prevent the next search (since we're about to set the value)\r\n-    preventNextSearch.current = true;\r\n-    console.log('üö´ Set flag to prevent next search');\r\n-    \r\n-    // Store the selected value to prevent re-searching\r\n+    // Store the selected value to prevent future searches\r\n     lastSelectedValue.current = selectedLocation;\r\n-    console.log('üíæ Stored selected value:', selectedLocation);\r\n     \r\n-    // Follow the same pattern as LocationSearch - hide suggestions first\r\n+    // Hide suggestions and update UI\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n     setSelectedIndex(-1);\r\n     \r\n-    // Set the value (this is what the user sees) - this will trigger the search effect\r\n+    // Set the input value\r\n     setSearchValue(selectedLocation);\r\n     \r\n     // Call the selection handler\r\n     onLocationSelect(selectedLocation);\r\n+    \r\n+    // Reset the selection flag after a short delay\r\n+    setTimeout(() => {\r\n+      isSelecting.current = false;\r\n+      console.log('üîÑ Selection flag reset');\r\n+    }, 100);\r\n   };\r\n \r\n   const handleKeyDown = (e: React.KeyboardEvent) => {\r\n-    if (!showSuggestions || predictions.length === 0) return;\r\n+    if (!showSuggestions) return;\r\n \r\n     switch (e.key) {\r\n       case 'ArrowDown':\r\n         e.preventDefault();\r\n@@ -231,8 +227,9 @@\n           handleSuggestionClick(predictions[selectedIndex]);\r\n         }\r\n         break;\r\n       case 'Escape':\r\n+        e.preventDefault();\r\n         setShowSuggestions(false);\r\n         setSelectedIndex(-1);\r\n         inputRef.current?.blur();\r\n         break;\r\n@@ -254,56 +251,50 @@\n   };\r\n \r\n   return (\r\n     <div className={`relative ${className}`}>\r\n-      <input\r\n-        ref={inputRef}\r\n-        type=\"text\"\r\n-        value={searchValue}\r\n-        onChange={handleInputChange}\r\n-        onKeyDown={handleKeyDown}\r\n-        onBlur={handleInputBlur}\r\n-        onFocus={handleInputFocus}\r\n-        placeholder={placeholder}\r\n-        className=\"input-field\"\r\n-        autoComplete=\"off\"\r\n-        required\r\n-      />\r\n-      \r\n-      {isLoading && (\r\n-        <div className=\"absolute right-3 top-1/2 transform -translate-y-1/2\">\r\n-          <div className=\"animate-spin rounded-full h-4 w-4 border-2 border-primary-600 border-t-transparent\"></div>\r\n+      <div className=\"relative\">\r\n+        <input\r\n+          ref={inputRef}\r\n+          type=\"text\"\r\n+          value={searchValue}\r\n+          onChange={handleInputChange}\r\n+          onKeyDown={handleKeyDown}\r\n+          onBlur={handleInputBlur}\r\n+          onFocus={handleInputFocus}\r\n+          placeholder={placeholder}\r\n+          className=\"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 pr-10\"\r\n+        />\r\n+        <div className=\"absolute inset-y-0 right-0 flex items-center pr-3\">\r\n+          {isLoading ? (\r\n+            <div className=\"animate-spin rounded-full h-4 w-4 border-2 border-gray-300 border-t-blue-500\"></div>\r\n+          ) : (\r\n+            <ChevronDownIcon className=\"h-4 w-4 text-gray-400\" />\r\n+          )}\r\n         </div>\r\n-      )}\r\n+      </div>\r\n \r\n       {showSuggestions && predictions.length > 0 && (\r\n         <div \r\n           ref={suggestionsRef}\r\n-          className=\"absolute z-50 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto\"\r\n+          className=\"absolute z-50 mt-1 w-full bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto\"\r\n         >\r\n           {predictions.map((prediction, index) => (\r\n             <div\r\n               key={prediction.place_id}\r\n+              className={`px-3 py-2 cursor-pointer hover:bg-gray-100 ${\r\n+                index === selectedIndex ? 'bg-blue-50' : ''\r\n+              }`}\r\n               onClick={() => handleSuggestionClick(prediction)}\r\n-              className={`px-4 py-3 cursor-pointer hover:bg-gray-50 transition-colors ${\r\n-                index === selectedIndex ? 'bg-primary-50 border-l-4 border-primary-600' : ''\r\n-              }`}\r\n             >\r\n-              <div className=\"flex items-center space-x-3\">\r\n-                <div className=\"flex-shrink-0\">\r\n-                  <div className=\"w-8 h-8 bg-primary-100 rounded-full flex items-center justify-center\">\r\n-                    <span className=\"text-primary-600 text-sm\">üåç</span>\r\n-                  </div>\r\n+              <div className=\"font-medium text-gray-900\">\r\n+                {prediction.structured_formatting?.main_text || prediction.description}\r\n+              </div>\r\n+              {prediction.structured_formatting?.secondary_text && (\r\n+                <div className=\"text-sm text-gray-500\">\r\n+                  {prediction.structured_formatting.secondary_text}\r\n                 </div>\r\n-                <div className=\"flex-1 min-w-0\">\r\n-                  <div className=\"text-sm font-medium text-gray-900\">\r\n-                    {prediction.structured_formatting?.main_text || prediction.description}\r\n-                  </div>\r\n-                  <div className=\"text-xs text-gray-500\">\r\n-                    {prediction.structured_formatting?.secondary_text || ''}\r\n-                  </div>\r\n-                </div>\r\n-              </div>\r\n+              )}\r\n             </div>\r\n           ))}\r\n         </div>\r\n       )}\r\n"
                },
                {
                    "date": 1752502029760,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,7 @@\n 'use client';\r\n \r\n import React, { useState, useRef, useEffect } from 'react';\r\n-import { ChevronDownIcon } from '@heroicons/react/20/solid';\r\n \r\n declare global {\r\n   interface Window {\r\n     google: any;\r\n"
                },
                {
                    "date": 1752502037801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -266,9 +266,9 @@\n         <div className=\"absolute inset-y-0 right-0 flex items-center pr-3\">\r\n           {isLoading ? (\r\n             <div className=\"animate-spin rounded-full h-4 w-4 border-2 border-gray-300 border-t-blue-500\"></div>\r\n           ) : (\r\n-            <ChevronDownIcon className=\"h-4 w-4 text-gray-400\" />\r\n+            <span className=\"text-gray-400\">‚ñº</span>\r\n           )}\r\n         </div>\r\n       </div>\r\n \r\n"
                },
                {
                    "date": 1752502525337,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,8 +66,12 @@\n   }, []);\r\n \r\n   // Handle search with debouncing and proper prevention logic\r\n   useEffect(() => {\r\n+    console.log('üîç Search effect triggered - searchValue:', searchValue);\r\n+    console.log('üîç isSelecting.current:', isSelecting.current);\r\n+    console.log('üîç lastSelectedValue.current:', lastSelectedValue.current);\r\n+    \r\n     // Clear any existing timeout\r\n     if (searchTimeout.current) {\r\n       clearTimeout(searchTimeout.current);\r\n     }\r\n@@ -83,15 +87,20 @@\n       console.log('üö´ Skipping search - same as last selected value:', searchValue);\r\n       return;\r\n     }\r\n \r\n+    // Don't search if searchValue is empty\r\n+    if (!searchValue.trim()) {\r\n+      console.log('üö´ Skipping search - empty value');\r\n+      setPredictions([]);\r\n+      setShowSuggestions(false);\r\n+      return;\r\n+    }\r\n+\r\n     searchTimeout.current = setTimeout(() => {\r\n-      if (searchValue.trim() && autocompleteService.current) {\r\n-        console.log('üîç Searching for cities/countries:', searchValue.trim());\r\n+      if (autocompleteService.current) {\r\n+        console.log('üîç Executing search for:', searchValue.trim());\r\n         handleSearch(searchValue.trim());\r\n-      } else {\r\n-        setPredictions([]);\r\n-        setShowSuggestions(false);\r\n       }\r\n     }, 300);\r\n \r\n     return () => {\r\n"
                },
                {
                    "date": 1752502540669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,37 +183,37 @@\n \r\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ Selected location:', selectedLocation);\r\n+    console.log('üõë Setting selection flags to prevent search...');\r\n     \r\n-    // Set the selection flag to prevent any searches\r\n+    // IMMEDIATELY set flags to prevent any searches\r\n     isSelecting.current = true;\r\n+    lastSelectedValue.current = selectedLocation;\r\n     \r\n-    // Cancel any pending search\r\n+    // Cancel any pending search timeout\r\n     if (searchTimeout.current) {\r\n       clearTimeout(searchTimeout.current);\r\n       searchTimeout.current = null;\r\n+      console.log('üö´ Cancelled pending search timeout');\r\n     }\r\n     \r\n-    // Store the selected value to prevent future searches\r\n-    lastSelectedValue.current = selectedLocation;\r\n-    \r\n-    // Hide suggestions and update UI\r\n+    // Hide suggestions and update UI state first\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n     setSelectedIndex(-1);\r\n     \r\n-    // Set the input value\r\n+    // Update the input value (this triggers the search effect)\r\n     setSearchValue(selectedLocation);\r\n     \r\n-    // Call the selection handler\r\n+    // Call the parent handler\r\n     onLocationSelect(selectedLocation);\r\n     \r\n-    // Reset the selection flag after a short delay\r\n+    // Reset the selection flag after the search effect has had time to run\r\n     setTimeout(() => {\r\n       isSelecting.current = false;\r\n-      console.log('üîÑ Selection flag reset');\r\n-    }, 100);\r\n+      console.log('üîÑ Selection flag reset - searches can resume');\r\n+    }, 500); // Increased delay to ensure search effect runs first\r\n   };\r\n \r\n   const handleKeyDown = (e: React.KeyboardEvent) => {\r\n     if (!showSuggestions) return;\r\n"
                },
                {
                    "date": 1752502560958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,14 +110,17 @@\n     };\r\n   }, [searchValue]);\r\n \r\n   const handleSearch = async (value: string) => {\r\n+    console.log('üîç handleSearch called with value:', value);\r\n+    \r\n     if (!autocompleteService.current) {\r\n       console.warn('‚ö†Ô∏è Autocomplete service not initialized');\r\n       return;\r\n     }\r\n \r\n     setIsLoading(true);\r\n+    console.log('üîç Searching for cities/countries:', value);\r\n \r\n     const request: google.maps.places.AutocompletionRequest = {\r\n       input: value,\r\n       types: ['(cities)'], // Focus on cities and administrative areas\r\n"
                },
                {
                    "date": 1752502573750,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,16 +169,20 @@\n   };\r\n \r\n   const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n     const value = e.target.value;\r\n+    console.log('üìù Input changed to:', value);\r\n+    console.log('üìù Last selected value was:', lastSelectedValue.current);\r\n+    \r\n     setSearchValue(value);\r\n     \r\n-    // Clear the last selected value when user starts typing something new\r\n+    // Clear the last selected value when user starts typing something different\r\n     if (lastSelectedValue.current && value !== lastSelectedValue.current) {\r\n       lastSelectedValue.current = '';\r\n       console.log('üóëÔ∏è Cleared last selected value - user is typing new input');\r\n     }\r\n     \r\n+    // If input is empty, hide suggestions\r\n     if (!value.trim()) {\r\n       setPredictions([]);\r\n       setShowSuggestions(false);\r\n     }\r\n"
                },
                {
                    "date": 1752502725308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,11 @@\n   value,\r\n   placeholder = \"e.g., Paris, France\",\r\n   className = \"\"\r\n }: CityCountrySearchProps) {\r\n-  const [searchValue, setSearchValue] = useState(value);\r\n+  // Separate display value from search value\r\n+  const [displayValue, setDisplayValue] = useState(value);\r\n+  const [searchQuery, setSearchQuery] = useState('');\r\n   const [predictions, setPredictions] = useState<google.maps.places.AutocompletePrediction[]>([]);\r\n   const [isLoading, setIsLoading] = useState(false);\r\n   const [showSuggestions, setShowSuggestions] = useState(false);\r\n   const [selectedIndex, setSelectedIndex] = useState(-1);\r\n@@ -30,16 +32,13 @@\n   const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n   const searchTimeout = useRef<NodeJS.Timeout | null>(null);\r\n-  const lastSelectedValue = useRef<string>('');\r\n-  const isSelecting = useRef<boolean>(false);\r\n \r\n   // Initialize Google Places service\r\n   useEffect(() => {\r\n     const initializeServices = async () => {\r\n       if (!window.google?.maps?.places) {\r\n-        // Load Google Places API if not already loaded\r\n         const script = document.createElement('script');\r\n         script.src = `https://maps.googleapis.com/maps/api/js?key=${process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}&libraries=places`;\r\n         script.async = true;\r\n         script.onload = () => {\r\n@@ -64,72 +63,49 @@\n \r\n     initializeServices();\r\n   }, []);\r\n \r\n-  // Handle search with debouncing and proper prevention logic\r\n+  // ONLY search based on searchQuery, not displayValue\r\n   useEffect(() => {\r\n-    console.log('üîç Search effect triggered - searchValue:', searchValue);\r\n-    console.log('üîç isSelecting.current:', isSelecting.current);\r\n-    console.log('üîç lastSelectedValue.current:', lastSelectedValue.current);\r\n-    \r\n-    // Clear any existing timeout\r\n     if (searchTimeout.current) {\r\n       clearTimeout(searchTimeout.current);\r\n     }\r\n \r\n-    // Don't search if we're in the middle of a selection\r\n-    if (isSelecting.current) {\r\n-      console.log('üö´ Skipping search - selection in progress');\r\n-      return;\r\n-    }\r\n-\r\n-    // Don't search if this is the same value we just selected\r\n-    if (searchValue === lastSelectedValue.current) {\r\n-      console.log('üö´ Skipping search - same as last selected value:', searchValue);\r\n-      return;\r\n-    }\r\n-\r\n-    // Don't search if searchValue is empty\r\n-    if (!searchValue.trim()) {\r\n-      console.log('üö´ Skipping search - empty value');\r\n+    if (!searchQuery.trim()) {\r\n       setPredictions([]);\r\n       setShowSuggestions(false);\r\n       return;\r\n     }\r\n \r\n+    console.log('üîç Searching for:', searchQuery);\r\n+    \r\n     searchTimeout.current = setTimeout(() => {\r\n       if (autocompleteService.current) {\r\n-        console.log('üîç Executing search for:', searchValue.trim());\r\n-        handleSearch(searchValue.trim());\r\n+        handleSearch(searchQuery);\r\n       }\r\n     }, 300);\r\n \r\n     return () => {\r\n       if (searchTimeout.current) {\r\n         clearTimeout(searchTimeout.current);\r\n       }\r\n     };\r\n-  }, [searchValue]);\r\n+  }, [searchQuery]); // Only depends on searchQuery\r\n \r\n-  const handleSearch = async (value: string) => {\r\n-    console.log('üîç handleSearch called with value:', value);\r\n-    \r\n+  const handleSearch = async (query: string) => {\r\n     if (!autocompleteService.current) {\r\n       console.warn('‚ö†Ô∏è Autocomplete service not initialized');\r\n       return;\r\n     }\r\n \r\n     setIsLoading(true);\r\n-    console.log('üîç Searching for cities/countries:', value);\r\n \r\n     const request: google.maps.places.AutocompletionRequest = {\r\n-      input: value,\r\n-      types: ['(cities)'], // Focus on cities and administrative areas\r\n-      // No componentRestrictions - allow worldwide search\r\n+      input: query,\r\n+      types: ['(cities)'],\r\n     };\r\n \r\n     try {\r\n-      // Use the promise-based approach to avoid the callback deprecation warning\r\n       const response = await new Promise<{\r\n         predictions: google.maps.places.AutocompletePrediction[];\r\n         status: google.maps.places.PlacesServiceStatus;\r\n       }>((resolve) => {\r\n@@ -142,18 +118,17 @@\n       \r\n       if (response.status === google.maps.places.PlacesServiceStatus.OK && response.predictions.length > 0) {\r\n         console.log('‚úÖ Found predictions:', response.predictions.length);\r\n         \r\n-        // Filter and sort predictions to prioritize cities and countries\r\n         const filteredPredictions = response.predictions.filter((prediction: google.maps.places.AutocompletePrediction) => {\r\n           const types = prediction.types || [];\r\n           return types.includes('locality') || \r\n                  types.includes('administrative_area_level_1') || \r\n                  types.includes('country') ||\r\n                  types.includes('political');\r\n         });\r\n \r\n-        setPredictions(filteredPredictions.slice(0, 5)); // Limit to 5 suggestions\r\n+        setPredictions(filteredPredictions.slice(0, 5));\r\n         setShowSuggestions(true);\r\n         setSelectedIndex(-1);\r\n       } else {\r\n         console.log('‚ùå No predictions found');\r\n@@ -168,59 +143,41 @@\n     }\r\n   };\r\n \r\n   const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n-    const value = e.target.value;\r\n-    console.log('üìù Input changed to:', value);\r\n-    console.log('üìù Last selected value was:', lastSelectedValue.current);\r\n+    const newValue = e.target.value;\r\n+    console.log('üìù User typed:', newValue);\r\n     \r\n-    setSearchValue(value);\r\n-    \r\n-    // Clear the last selected value when user starts typing something different\r\n-    if (lastSelectedValue.current && value !== lastSelectedValue.current) {\r\n-      lastSelectedValue.current = '';\r\n-      console.log('üóëÔ∏è Cleared last selected value - user is typing new input');\r\n-    }\r\n-    \r\n-    // If input is empty, hide suggestions\r\n-    if (!value.trim()) {\r\n-      setPredictions([]);\r\n-      setShowSuggestions(false);\r\n-    }\r\n+    // Update both display and search values when user types\r\n+    setDisplayValue(newValue);\r\n+    setSearchQuery(newValue);\r\n   };\r\n \r\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n-    console.log('‚úÖ Selected location:', selectedLocation);\r\n-    console.log('üõë Setting selection flags to prevent search...');\r\n+    console.log('‚úÖ User selected:', selectedLocation);\r\n     \r\n-    // IMMEDIATELY set flags to prevent any searches\r\n-    isSelecting.current = true;\r\n-    lastSelectedValue.current = selectedLocation;\r\n+    // Clear search query to stop any searches\r\n+    setSearchQuery('');\r\n     \r\n-    // Cancel any pending search timeout\r\n-    if (searchTimeout.current) {\r\n-      clearTimeout(searchTimeout.current);\r\n-      searchTimeout.current = null;\r\n-      console.log('üö´ Cancelled pending search timeout');\r\n-    }\r\n+    // Set display value to show the selection\r\n+    setDisplayValue(selectedLocation);\r\n     \r\n-    // Hide suggestions and update UI state first\r\n+    // Hide suggestions\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n     setSelectedIndex(-1);\r\n     \r\n-    // Update the input value (this triggers the search effect)\r\n-    setSearchValue(selectedLocation);\r\n+    // Cancel any pending search\r\n+    if (searchTimeout.current) {\r\n+      clearTimeout(searchTimeout.current);\r\n+      searchTimeout.current = null;\r\n+    }\r\n     \r\n-    // Call the parent handler\r\n+    // Notify parent\r\n     onLocationSelect(selectedLocation);\r\n     \r\n-    // Reset the selection flag after the search effect has had time to run\r\n-    setTimeout(() => {\r\n-      isSelecting.current = false;\r\n-      console.log('üîÑ Selection flag reset - searches can resume');\r\n-    }, 500); // Increased delay to ensure search effect runs first\r\n+    console.log('‚úÖ Selection complete - no more searches will trigger');\r\n   };\r\n \r\n   const handleKeyDown = (e: React.KeyboardEvent) => {\r\n     if (!showSuggestions) return;\r\n@@ -251,17 +208,16 @@\n     }\r\n   };\r\n \r\n   const handleInputBlur = () => {\r\n-    // Delay hiding suggestions to allow for clicks\r\n     setTimeout(() => {\r\n       setShowSuggestions(false);\r\n       setSelectedIndex(-1);\r\n     }, 200);\r\n   };\r\n \r\n   const handleInputFocus = () => {\r\n-    if (predictions.length > 0) {\r\n+    if (predictions.length > 0 && searchQuery.trim()) {\r\n       setShowSuggestions(true);\r\n     }\r\n   };\r\n \r\n@@ -270,9 +226,9 @@\n       <div className=\"relative\">\r\n         <input\r\n           ref={inputRef}\r\n           type=\"text\"\r\n-          value={searchValue}\r\n+          value={displayValue}\r\n           onChange={handleInputChange}\r\n           onKeyDown={handleKeyDown}\r\n           onBlur={handleInputBlur}\r\n           onFocus={handleInputFocus}\r\n"
                },
                {
                    "date": 1752503030398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n   value,\r\n   placeholder = \"e.g., Paris, France\",\r\n   className = \"\"\r\n }: CityCountrySearchProps) {\r\n-  // Separate display value from search value\r\n+  // Separate display value from search value to prevent re-search after selection\r\n   const [displayValue, setDisplayValue] = useState(value);\r\n   const [searchQuery, setSearchQuery] = useState('');\r\n   const [predictions, setPredictions] = useState<google.maps.places.AutocompletePrediction[]>([]);\r\n   const [isLoading, setIsLoading] = useState(false);\r\n@@ -32,8 +32,9 @@\n   const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n   const inputRef = useRef<HTMLInputElement>(null);\r\n   const suggestionsRef = useRef<HTMLDivElement>(null);\r\n   const searchTimeout = useRef<NodeJS.Timeout | null>(null);\r\n+  const isSelectingRef = useRef(false); // Flag to prevent input change from triggering search during selection\r\n \r\n   // Initialize Google Places service\r\n   useEffect(() => {\r\n     const initializeServices = async () => {\r\n"
                },
                {
                    "date": 1752503044287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,12 +146,19 @@\n \r\n   const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n     const newValue = e.target.value;\r\n     console.log('üìù User typed:', newValue);\r\n+    console.log('üìù isSelectingRef.current:', isSelectingRef.current);\r\n     \r\n-    // Update both display and search values when user types\r\n+    // Update display value\r\n     setDisplayValue(newValue);\r\n-    setSearchQuery(newValue);\r\n+    \r\n+    // Only update search query if we're not in the middle of a selection\r\n+    if (!isSelectingRef.current) {\r\n+      setSearchQuery(newValue);\r\n+    } else {\r\n+      console.log('üö´ Skipping search query update - selection in progress');\r\n+    }\r\n   };\r\n \r\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n"
                },
                {
                    "date": 1752503065687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,13 +163,19 @@\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n     console.log('‚úÖ User selected:', selectedLocation);\r\n     \r\n+    // Set flag to prevent input change from triggering search\r\n+    isSelectingRef.current = true;\r\n+    console.log('üõë Set isSelectingRef to true - preventing search during selection');\r\n+    \r\n     // Clear search query to stop any searches\r\n     setSearchQuery('');\r\n+    console.log('üõë Cleared search query');\r\n     \r\n-    // Set display value to show the selection\r\n+    // Set display value to show the selection (this will trigger onChange)\r\n     setDisplayValue(selectedLocation);\r\n+    console.log('üõë Set display value to:', selectedLocation);\r\n     \r\n     // Hide suggestions\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n@@ -178,14 +184,19 @@\n     // Cancel any pending search\r\n     if (searchTimeout.current) {\r\n       clearTimeout(searchTimeout.current);\r\n       searchTimeout.current = null;\r\n+      console.log('üõë Cancelled pending search timeout');\r\n     }\r\n     \r\n-    // Notify parent\r\n+    // Reset the flag after a short delay to allow normal typing again\r\n+    setTimeout(() => {\r\n+      isSelectingRef.current = false;\r\n+      console.log('üîÑ Reset isSelectingRef to false - normal typing resumed');\r\n+    }, 100);\r\n+    \r\n+    // Notify parent component\r\n     onLocationSelect(selectedLocation);\r\n-    \r\n-    console.log('‚úÖ Selection complete - no more searches will trigger');\r\n   };\r\n \r\n   const handleKeyDown = (e: React.KeyboardEvent) => {\r\n     if (!showSuggestions) return;\r\n"
                },
                {
                    "date": 1752503275663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,10 +20,10 @@\n   value,\r\n   placeholder = \"e.g., Paris, France\",\r\n   className = \"\"\r\n }: CityCountrySearchProps) {\r\n-  // Separate display value from search value to prevent re-search after selection\r\n-  const [displayValue, setDisplayValue] = useState(value);\r\n+  // Use inputValue for the input field, searchQuery only for triggering search\r\n+  const [inputValue, setInputValue] = useState(value);\r\n   const [searchQuery, setSearchQuery] = useState('');\r\n   const [predictions, setPredictions] = useState<google.maps.places.AutocompletePrediction[]>([]);\r\n   const [isLoading, setIsLoading] = useState(false);\r\n   const [showSuggestions, setShowSuggestions] = useState(false);\r\n@@ -143,59 +143,27 @@\n       setShowSuggestions(false);\r\n     }\r\n   };\r\n \r\n+  // Only update searchQuery on user typing\r\n   const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n     const newValue = e.target.value;\r\n-    console.log('üìù User typed:', newValue);\r\n-    console.log('üìù isSelectingRef.current:', isSelectingRef.current);\r\n-    \r\n-    // Update display value\r\n-    setDisplayValue(newValue);\r\n-    \r\n-    // Only update search query if we're not in the middle of a selection\r\n-    if (!isSelectingRef.current) {\r\n-      setSearchQuery(newValue);\r\n-    } else {\r\n-      console.log('üö´ Skipping search query update - selection in progress');\r\n-    }\r\n+    setInputValue(newValue);\r\n+    setSearchQuery(newValue); // Only here!\r\n   };\r\n \r\n+  // On suggestion click, set inputValue but do NOT update searchQuery\r\n   const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n     const selectedLocation = prediction.description;\r\n-    console.log('‚úÖ User selected:', selectedLocation);\r\n-    \r\n-    // Set flag to prevent input change from triggering search\r\n-    isSelectingRef.current = true;\r\n-    console.log('üõë Set isSelectingRef to true - preventing search during selection');\r\n-    \r\n-    // Clear search query to stop any searches\r\n-    setSearchQuery('');\r\n-    console.log('üõë Cleared search query');\r\n-    \r\n-    // Set display value to show the selection (this will trigger onChange)\r\n-    setDisplayValue(selectedLocation);\r\n-    console.log('üõë Set display value to:', selectedLocation);\r\n-    \r\n-    // Hide suggestions\r\n+    setInputValue(selectedLocation);\r\n+    setSearchQuery(''); // Clear searchQuery so no search is triggered\r\n     setShowSuggestions(false);\r\n     setPredictions([]);\r\n     setSelectedIndex(-1);\r\n-    \r\n-    // Cancel any pending search\r\n     if (searchTimeout.current) {\r\n       clearTimeout(searchTimeout.current);\r\n       searchTimeout.current = null;\r\n-      console.log('üõë Cancelled pending search timeout');\r\n     }\r\n-    \r\n-    // Reset the flag after a short delay to allow normal typing again\r\n-    setTimeout(() => {\r\n-      isSelectingRef.current = false;\r\n-      console.log('üîÑ Reset isSelectingRef to false - normal typing resumed');\r\n-    }, 100);\r\n-    \r\n-    // Notify parent component\r\n     onLocationSelect(selectedLocation);\r\n   };\r\n \r\n   const handleKeyDown = (e: React.KeyboardEvent) => {\r\n@@ -245,9 +213,9 @@\n       <div className=\"relative\">\r\n         <input\r\n           ref={inputRef}\r\n           type=\"text\"\r\n-          value={displayValue}\r\n+          value={inputValue}\r\n           onChange={handleInputChange}\r\n           onKeyDown={handleKeyDown}\r\n           onBlur={handleInputBlur}\r\n           onFocus={handleInputFocus}\r\n"
                },
                {
                    "date": 1752579534283,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,12 +121,10 @@\n         console.log('‚úÖ Found predictions:', response.predictions.length);\r\n         \r\n         const filteredPredictions = response.predictions.filter((prediction: google.maps.places.AutocompletePrediction) => {\r\n           const types = prediction.types || [];\r\n-          return types.includes('locality') || \r\n-                 types.includes('administrative_area_level_1') || \r\n-                 types.includes('country') ||\r\n-                 types.includes('political');\r\n+          // Only allow cities and countries\r\n+          return types.includes('locality') || types.includes('country');\r\n         });\r\n \r\n         setPredictions(filteredPredictions.slice(0, 5));\r\n         setShowSuggestions(true);\r\n"
                }
            ],
            "date": 1752500032569,
            "name": "Commit-0",
            "content": "'use client';\r\n\r\nimport { useState, useEffect, useRef } from 'react';\r\n\r\ninterface CityCountrySearchProps {\r\n  onLocationSelect: (location: string) => void;\r\n  value: string;\r\n  placeholder?: string;\r\n  className?: string;\r\n}\r\n\r\nexport default function CityCountrySearch({\r\n  onLocationSelect,\r\n  value,\r\n  placeholder = \"e.g., Paris, France\",\r\n  className = \"\"\r\n}: CityCountrySearchProps) {\r\n  const [searchValue, setSearchValue] = useState(value);\r\n  const [predictions, setPredictions] = useState<google.maps.places.AutocompletePrediction[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [showSuggestions, setShowSuggestions] = useState(false);\r\n  const [selectedIndex, setSelectedIndex] = useState(-1);\r\n  \r\n  const autocompleteService = useRef<google.maps.places.AutocompleteService | null>(null);\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n  const suggestionsRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Update local state when value prop changes\r\n  useEffect(() => {\r\n    setSearchValue(value);\r\n  }, [value]);\r\n\r\n  // Initialize Google Places services\r\n  useEffect(() => {\r\n    const initializeServices = async () => {\r\n      // Check if Google Maps is already loaded\r\n      if (!window.google?.maps?.places) {\r\n        // Load Google Maps if not already loaded\r\n        const apiKey = process.env.NEXT_PUBLIC_GOOGLE_PLACES_API_KEY || process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;\r\n        if (!apiKey) {\r\n          console.error('‚ùå Google Places API key not found');\r\n          return;\r\n        }\r\n\r\n        console.log('üìç Loading Google Maps with Places API for city/country search...');\r\n\r\n        const script = document.createElement('script');\r\n        script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places`;\r\n        script.async = true;\r\n        script.defer = true;\r\n        \r\n        script.onload = () => {\r\n          console.log('‚úÖ Google Places API loaded successfully');\r\n          setupServices();\r\n        };\r\n        \r\n        script.onerror = () => {\r\n          console.error('‚ùå Failed to load Google Places API');\r\n        };\r\n        \r\n        document.head.appendChild(script);\r\n      } else {\r\n        setupServices();\r\n      }\r\n    };\r\n\r\n    const setupServices = () => {\r\n      if (window.google?.maps?.places) {\r\n        autocompleteService.current = new google.maps.places.AutocompleteService();\r\n        console.log('‚úÖ City/Country autocomplete service initialized');\r\n      }\r\n    };\r\n\r\n    initializeServices();\r\n  }, []);\r\n\r\n  // Handle search with debouncing\r\n  useEffect(() => {\r\n    const timeoutId = setTimeout(() => {\r\n      if (searchValue.trim() && autocompleteService.current) {\r\n        handleSearch(searchValue.trim());\r\n      } else {\r\n        setPredictions([]);\r\n        setShowSuggestions(false);\r\n      }\r\n    }, 300);\r\n\r\n    return () => clearTimeout(timeoutId);\r\n  }, [searchValue]);\r\n\r\n  const handleSearch = (value: string) => {\r\n    if (!autocompleteService.current) {\r\n      console.warn('‚ö†Ô∏è Autocomplete service not initialized');\r\n      return;\r\n    }\r\n\r\n    setIsLoading(true);\r\n    console.log('üîç Searching for cities/countries:', value);\r\n\r\n    const request: google.maps.places.AutocompletionRequest = {\r\n      input: value,\r\n      types: ['(cities)'], // Focus on cities and administrative areas\r\n      componentRestrictions: {}, // No country restrictions - allow worldwide search\r\n    };\r\n\r\n    autocompleteService.current.getPlacePredictions(request, (predictions, status) => {\r\n      setIsLoading(false);\r\n      \r\n      if (status === google.maps.places.PlacesServiceStatus.OK && predictions) {\r\n        console.log('‚úÖ Found predictions:', predictions.length);\r\n        \r\n        // Filter and sort predictions to prioritize cities and countries\r\n        const filteredPredictions = predictions.filter(prediction => {\r\n          const types = prediction.types || [];\r\n          return types.includes('locality') || \r\n                 types.includes('administrative_area_level_1') || \r\n                 types.includes('country') ||\r\n                 types.includes('political');\r\n        });\r\n\r\n        setPredictions(filteredPredictions.slice(0, 5)); // Limit to 5 suggestions\r\n        setShowSuggestions(true);\r\n        setSelectedIndex(-1);\r\n      } else {\r\n        console.log('‚ùå No predictions found or error:', status);\r\n        setPredictions([]);\r\n        setShowSuggestions(false);\r\n      }\r\n    });\r\n  };\r\n\r\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const value = e.target.value;\r\n    setSearchValue(value);\r\n    \r\n    if (!value.trim()) {\r\n      setPredictions([]);\r\n      setShowSuggestions(false);\r\n    }\r\n  };\r\n\r\n  const handleSuggestionClick = (prediction: google.maps.places.AutocompletePrediction) => {\r\n    const selectedLocation = prediction.description;\r\n    console.log('‚úÖ Selected location:', selectedLocation);\r\n    \r\n    setSearchValue(selectedLocation);\r\n    setShowSuggestions(false);\r\n    setPredictions([]);\r\n    setSelectedIndex(-1);\r\n    \r\n    onLocationSelect(selectedLocation);\r\n  };\r\n\r\n  const handleKeyDown = (e: React.KeyboardEvent) => {\r\n    if (!showSuggestions || predictions.length === 0) return;\r\n\r\n    switch (e.key) {\r\n      case 'ArrowDown':\r\n        e.preventDefault();\r\n        setSelectedIndex(prev => \r\n          prev < predictions.length - 1 ? prev + 1 : prev\r\n        );\r\n        break;\r\n      case 'ArrowUp':\r\n        e.preventDefault();\r\n        setSelectedIndex(prev => prev > 0 ? prev - 1 : prev);\r\n        break;\r\n      case 'Enter':\r\n        e.preventDefault();\r\n        if (selectedIndex >= 0 && selectedIndex < predictions.length) {\r\n          handleSuggestionClick(predictions[selectedIndex]);\r\n        }\r\n        break;\r\n      case 'Escape':\r\n        setShowSuggestions(false);\r\n        setSelectedIndex(-1);\r\n        inputRef.current?.blur();\r\n        break;\r\n    }\r\n  };\r\n\r\n  const handleInputBlur = () => {\r\n    // Delay hiding suggestions to allow for clicks\r\n    setTimeout(() => {\r\n      setShowSuggestions(false);\r\n      setSelectedIndex(-1);\r\n    }, 200);\r\n  };\r\n\r\n  const handleInputFocus = () => {\r\n    if (predictions.length > 0) {\r\n      setShowSuggestions(true);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={`relative ${className}`}>\r\n      <input\r\n        ref={inputRef}\r\n        type=\"text\"\r\n        value={searchValue}\r\n        onChange={handleInputChange}\r\n        onKeyDown={handleKeyDown}\r\n        onBlur={handleInputBlur}\r\n        onFocus={handleInputFocus}\r\n        placeholder={placeholder}\r\n        className=\"input-field\"\r\n        autoComplete=\"off\"\r\n        required\r\n      />\r\n      \r\n      {isLoading && (\r\n        <div className=\"absolute right-3 top-1/2 transform -translate-y-1/2\">\r\n          <div className=\"animate-spin rounded-full h-4 w-4 border-2 border-primary-600 border-t-transparent\"></div>\r\n        </div>\r\n      )}\r\n\r\n      {showSuggestions && predictions.length > 0 && (\r\n        <div \r\n          ref={suggestionsRef}\r\n          className=\"absolute z-50 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto\"\r\n        >\r\n          {predictions.map((prediction, index) => (\r\n            <div\r\n              key={prediction.place_id}\r\n              onClick={() => handleSuggestionClick(prediction)}\r\n              className={`px-4 py-3 cursor-pointer hover:bg-gray-50 transition-colors ${\r\n                index === selectedIndex ? 'bg-primary-50 border-l-4 border-primary-600' : ''\r\n              }`}\r\n            >\r\n              <div className=\"flex items-center space-x-3\">\r\n                <div className=\"flex-shrink-0\">\r\n                  <div className=\"w-8 h-8 bg-primary-100 rounded-full flex items-center justify-center\">\r\n                    <span className=\"text-primary-600 text-sm\">üåç</span>\r\n                  </div>\r\n                </div>\r\n                <div className=\"flex-1 min-w-0\">\r\n                  <div className=\"text-sm font-medium text-gray-900\">\r\n                    {prediction.structured_formatting?.main_text || prediction.description}\r\n                  </div>\r\n                  <div className=\"text-xs text-gray-500\">\r\n                    {prediction.structured_formatting?.secondary_text || ''}\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n} "
        }
    ]
}