{
    "sourceFile": "lib/destination-service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1752433527529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752441052876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,18 +18,50 @@\n \r\n // Create a new destination\r\n export async function createDestination(destinationData: CreateDestinationData): Promise<string> {\r\n   try {\r\n+    console.log('Creating destination:', destinationData);\r\n+    \r\n+    // Validate required fields\r\n+    if (!destinationData.tripId) {\r\n+      throw new Error('Trip ID is required');\r\n+    }\r\n+    if (!destinationData.locationName) {\r\n+      throw new Error('Location name is required');\r\n+    }\r\n+    if (!destinationData.address) {\r\n+      throw new Error('Address is required');\r\n+    }\r\n+    if (typeof destinationData.lat !== 'number' || typeof destinationData.lng !== 'number') {\r\n+      throw new Error('Valid coordinates are required');\r\n+    }\r\n+    if (!destinationData.day || destinationData.day < 1) {\r\n+      throw new Error('Valid day number is required');\r\n+    }\r\n+    if (!destinationData.orderIndex || destinationData.orderIndex < 1) {\r\n+      throw new Error('Valid order index is required');\r\n+    }\r\n+\r\n     const destinationWithTimestamps = {\r\n       ...destinationData,\r\n       createdAt: Timestamp.now(),\r\n       updatedAt: Timestamp.now(),\r\n     };\r\n     \r\n+    console.log('Destination data with timestamps:', destinationWithTimestamps);\r\n+    \r\n     const docRef = await addDoc(collection(db, DESTINATIONS_COLLECTION), destinationWithTimestamps);\r\n+    console.log('Destination created successfully with ID:', docRef.id);\r\n+    \r\n     return docRef.id;\r\n   } catch (error) {\r\n     console.error('Error creating destination:', error);\r\n+    console.error('Error details:', {\r\n+      message: error instanceof Error ? error.message : 'Unknown error',\r\n+      stack: error instanceof Error ? error.stack : undefined,\r\n+      code: (error as any).code,\r\n+      customData: (error as any).customData,\r\n+    });\r\n     throw error;\r\n   }\r\n }\r\n \r\n"
                },
                {
                    "date": 1752441421037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,10 +40,31 @@\n     if (!destinationData.orderIndex || destinationData.orderIndex < 1) {\r\n       throw new Error('Valid order index is required');\r\n     }\r\n \r\n+    // Clean the data - remove undefined values that might cause Firestore issues\r\n+    const cleanedData: any = {\r\n+      tripId: destinationData.tripId,\r\n+      locationName: destinationData.locationName,\r\n+      address: destinationData.address,\r\n+      lat: destinationData.lat,\r\n+      lng: destinationData.lng,\r\n+      day: destinationData.day,\r\n+      orderIndex: destinationData.orderIndex,\r\n+    };\r\n+\r\n+    // Add optional fields only if they have valid values\r\n+    if (destinationData.startTime) cleanedData.startTime = destinationData.startTime;\r\n+    if (destinationData.endTime) cleanedData.endTime = destinationData.endTime;\r\n+    if (destinationData.notes) cleanedData.notes = destinationData.notes;\r\n+    if (destinationData.placeId) cleanedData.placeId = destinationData.placeId;\r\n+    if (destinationData.category) cleanedData.category = destinationData.category;\r\n+    if (typeof destinationData.rating === 'number') cleanedData.rating = destinationData.rating;\r\n+    if (typeof destinationData.priceLevel === 'number') cleanedData.priceLevel = destinationData.priceLevel;\r\n+    if (destinationData.photos && destinationData.photos.length > 0) cleanedData.photos = destinationData.photos;\r\n+\r\n     const destinationWithTimestamps = {\r\n-      ...destinationData,\r\n+      ...cleanedData,\r\n       createdAt: Timestamp.now(),\r\n       updatedAt: Timestamp.now(),\r\n     };\r\n     \r\n"
                },
                {
                    "date": 1752441473897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,10 +18,8 @@\n \r\n // Create a new destination\r\n export async function createDestination(destinationData: CreateDestinationData): Promise<string> {\r\n   try {\r\n-    console.log('Creating destination:', destinationData);\r\n-    \r\n     // Validate required fields\r\n     if (!destinationData.tripId) {\r\n       throw new Error('Trip ID is required');\r\n     }\r\n@@ -67,21 +65,16 @@\n       createdAt: Timestamp.now(),\r\n       updatedAt: Timestamp.now(),\r\n     };\r\n     \r\n-    console.log('Destination data with timestamps:', destinationWithTimestamps);\r\n-    \r\n     const docRef = await addDoc(collection(db, DESTINATIONS_COLLECTION), destinationWithTimestamps);\r\n-    console.log('Destination created successfully with ID:', docRef.id);\r\n     \r\n     return docRef.id;\r\n   } catch (error) {\r\n     console.error('Error creating destination:', error);\r\n     console.error('Error details:', {\r\n       message: error instanceof Error ? error.message : 'Unknown error',\r\n-      stack: error instanceof Error ? error.stack : undefined,\r\n       code: (error as any).code,\r\n-      customData: (error as any).customData,\r\n     });\r\n     throw error;\r\n   }\r\n }\r\n"
                },
                {
                    "date": 1754150141970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,11 +9,13 @@\n   query,\r\n   where,\r\n   orderBy,\r\n   Timestamp,\r\n+  runTransaction,\r\n } from 'firebase/firestore';\r\n import { db } from './firebase';\r\n import { Destination, CreateDestinationData, UpdateDestinationData } from '@/types';\r\n+import { logTripActivity, getUserTripPermission } from './sharing-service';\r\n \r\n const DESTINATIONS_COLLECTION = 'destinations';\r\n \r\n // Create a new destination\r\n@@ -31,10 +33,10 @@\n     }\r\n     if (typeof destinationData.lat !== 'number' || typeof destinationData.lng !== 'number') {\r\n       throw new Error('Valid coordinates are required');\r\n     }\r\n-    if (!destinationData.day || destinationData.day < 1) {\r\n-      throw new Error('Valid day number is required');\r\n+    if (typeof destinationData.day !== 'number' || destinationData.day < 0) {\r\n+      throw new Error('Valid day number is required (0 for ungrouped, 1+ for specific days)');\r\n     }\r\n     if (!destinationData.orderIndex || destinationData.orderIndex < 1) {\r\n       throw new Error('Valid order index is required');\r\n     }\r\n@@ -245,5 +247,208 @@\n   } catch (error) {\r\n     console.error('Error deleting all trip destinations:', error);\r\n     throw error;\r\n   }\r\n+}\r\n+\r\n+// Collaborative editing functions with permission checks and conflict resolution\r\n+\r\n+// Create destination with permission check and activity logging\r\n+export async function createDestinationWithAuth(\r\n+  destinationData: CreateDestinationData,\r\n+  userId: string,\r\n+  userDisplayName?: string\r\n+): Promise<string> {\r\n+  try {\r\n+    // Check user permission\r\n+    const permission = await getUserTripPermission(destinationData.tripId, userId);\r\n+    if (permission !== 'owner' && permission !== 'edit') {\r\n+      throw new Error('Insufficient permissions to add destinations');\r\n+    }\r\n+\r\n+    const destinationId = await createDestination(destinationData);\r\n+    \r\n+    // Log activity\r\n+    await logTripActivity(\r\n+      destinationData.tripId,\r\n+      userId,\r\n+      'added_destination',\r\n+      `Added destination: ${destinationData.locationName}`,\r\n+      userDisplayName\r\n+    );\r\n+\r\n+    return destinationId;\r\n+  } catch (error) {\r\n+    console.error('Error creating destination with auth:', error);\r\n+    throw error;\r\n+  }\r\n+}\r\n+\r\n+// Update destination with permission check and conflict resolution\r\n+export async function updateDestinationWithAuth(\r\n+  destinationId: string,\r\n+  updates: UpdateDestinationData,\r\n+  userId: string,\r\n+  userDisplayName?: string\r\n+): Promise<void> {\r\n+  try {\r\n+    return await runTransaction(db, async (transaction) => {\r\n+      const destinationRef = doc(db, DESTINATIONS_COLLECTION, destinationId);\r\n+      const destinationDoc = await transaction.get(destinationRef);\r\n+      \r\n+      if (!destinationDoc.exists()) {\r\n+        throw new Error('Destination not found');\r\n+      }\r\n+\r\n+      const destinationData = destinationDoc.data() as Destination;\r\n+      \r\n+      // Check user permission\r\n+      const permission = await getUserTripPermission(destinationData.tripId, userId);\r\n+      if (permission !== 'owner' && permission !== 'edit') {\r\n+        throw new Error('Insufficient permissions to edit destinations');\r\n+      }\r\n+\r\n+      // Check for conflicts (simple last-writer-wins for now)\r\n+      if (updates.updatedAt && destinationData.updatedAt) {\r\n+        const localUpdate = updates.updatedAt instanceof Date ? updates.updatedAt : updates.updatedAt.toDate();\r\n+        const serverUpdate = destinationData.updatedAt instanceof Date ? destinationData.updatedAt : destinationData.updatedAt.toDate();\r\n+        \r\n+        if (localUpdate < serverUpdate) {\r\n+          console.warn('Potential conflict detected, server version is newer');\r\n+          // For now, we'll proceed with last-writer-wins\r\n+          // In the future, we could implement more sophisticated conflict resolution\r\n+        }\r\n+      }\r\n+\r\n+      const updateData = {\r\n+        ...updates,\r\n+        updatedAt: Timestamp.now(),\r\n+      };\r\n+\r\n+      transaction.update(destinationRef, updateData);\r\n+\r\n+      // Log activity (outside transaction)\r\n+      setTimeout(() => {\r\n+        logTripActivity(\r\n+          destinationData.tripId,\r\n+          userId,\r\n+          'updated_destination',\r\n+          `Updated destination: ${destinationData.locationName}`,\r\n+          userDisplayName\r\n+        );\r\n+      }, 0);\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error updating destination with auth:', error);\r\n+    throw error;\r\n+  }\r\n+}\r\n+\r\n+// Delete destination with permission check\r\n+export async function deleteDestinationWithAuth(\r\n+  destinationId: string,\r\n+  userId: string,\r\n+  userDisplayName?: string\r\n+): Promise<void> {\r\n+  try {\r\n+    // Get destination first to check trip and log activity\r\n+    const destinationRef = doc(db, DESTINATIONS_COLLECTION, destinationId);\r\n+    const destinationDoc = await getDoc(destinationRef);\r\n+    \r\n+    if (!destinationDoc.exists()) {\r\n+      throw new Error('Destination not found');\r\n+    }\r\n+\r\n+    const destinationData = destinationDoc.data() as Destination;\r\n+    \r\n+    // Check user permission\r\n+    const permission = await getUserTripPermission(destinationData.tripId, userId);\r\n+    if (permission !== 'owner' && permission !== 'edit') {\r\n+      throw new Error('Insufficient permissions to delete destinations');\r\n+    }\r\n+\r\n+    await deleteDestination(destinationId);\r\n+    \r\n+    // Log activity\r\n+    await logTripActivity(\r\n+      destinationData.tripId,\r\n+      userId,\r\n+      'removed_destination',\r\n+      `Removed destination: ${destinationData.locationName}`,\r\n+      userDisplayName\r\n+    );\r\n+  } catch (error) {\r\n+    console.error('Error deleting destination with auth:', error);\r\n+    throw error;\r\n+  }\r\n+}\r\n+\r\n+// Reorder destinations with permission check\r\n+export async function reorderDestinationsWithAuth(\r\n+  destinations: Destination[],\r\n+  userId: string,\r\n+  userDisplayName?: string\r\n+): Promise<void> {\r\n+  try {\r\n+    if (destinations.length === 0) return;\r\n+    \r\n+    // Check user permission for the trip\r\n+    const permission = await getUserTripPermission(destinations[0].tripId, userId);\r\n+    if (permission !== 'owner' && permission !== 'edit') {\r\n+      throw new Error('Insufficient permissions to reorder destinations');\r\n+    }\r\n+\r\n+    await reorderDestinations(destinations);\r\n+    \r\n+    // Log activity\r\n+    await logTripActivity(\r\n+      destinations[0].tripId,\r\n+      userId,\r\n+      'updated_destination',\r\n+      `Reordered destinations`,\r\n+      userDisplayName\r\n+    );\r\n+  } catch (error) {\r\n+    console.error('Error reordering destinations with auth:', error);\r\n+    throw error;\r\n+  }\r\n+}\r\n+\r\n+// Move destination to different day with permission check\r\n+export async function moveDestinationToDayWithAuth(\r\n+  destinationId: string,\r\n+  newDay: number,\r\n+  userId: string,\r\n+  userDisplayName?: string\r\n+): Promise<void> {\r\n+  try {\r\n+    // Get destination first to check trip and log activity\r\n+    const destinationRef = doc(db, DESTINATIONS_COLLECTION, destinationId);\r\n+    const destinationDoc = await getDoc(destinationRef);\r\n+    \r\n+    if (!destinationDoc.exists()) {\r\n+      throw new Error('Destination not found');\r\n+    }\r\n+\r\n+    const destinationData = destinationDoc.data() as Destination;\r\n+    \r\n+    // Check user permission\r\n+    const permission = await getUserTripPermission(destinationData.tripId, userId);\r\n+    if (permission !== 'owner' && permission !== 'edit') {\r\n+      throw new Error('Insufficient permissions to move destinations');\r\n+    }\r\n+\r\n+    await moveDestinationToDay(destinationId, newDay);\r\n+    \r\n+    // Log activity\r\n+    await logTripActivity(\r\n+      destinationData.tripId,\r\n+      userId,\r\n+      'moved_destination',\r\n+      `Moved ${destinationData.locationName} to day ${newDay}`,\r\n+      userDisplayName\r\n+    );\r\n+  } catch (error) {\r\n+    console.error('Error moving destination with auth:', error);\r\n+    throw error;\r\n+  }\r\n } \n\\ No newline at end of file\n"
                }
            ],
            "date": 1752433527529,
            "name": "Commit-0",
            "content": "import {\r\n  collection,\r\n  doc,\r\n  addDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  getDocs,\r\n  getDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  Timestamp,\r\n} from 'firebase/firestore';\r\nimport { db } from './firebase';\r\nimport { Destination, CreateDestinationData, UpdateDestinationData } from '@/types';\r\n\r\nconst DESTINATIONS_COLLECTION = 'destinations';\r\n\r\n// Create a new destination\r\nexport async function createDestination(destinationData: CreateDestinationData): Promise<string> {\r\n  try {\r\n    const destinationWithTimestamps = {\r\n      ...destinationData,\r\n      createdAt: Timestamp.now(),\r\n      updatedAt: Timestamp.now(),\r\n    };\r\n    \r\n    const docRef = await addDoc(collection(db, DESTINATIONS_COLLECTION), destinationWithTimestamps);\r\n    return docRef.id;\r\n  } catch (error) {\r\n    console.error('Error creating destination:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Get all destinations for a trip\r\nexport async function getTripDestinations(tripId: string): Promise<Destination[]> {\r\n  try {\r\n    const q = query(\r\n      collection(db, DESTINATIONS_COLLECTION),\r\n      where('tripId', '==', tripId)\r\n    );\r\n    \r\n    const querySnapshot = await getDocs(q);\r\n    const destinations: Destination[] = [];\r\n    \r\n    querySnapshot.forEach((doc) => {\r\n      const data = doc.data();\r\n      destinations.push({\r\n        id: doc.id,\r\n        ...data,\r\n        createdAt: data.createdAt.toDate(),\r\n        updatedAt: data.updatedAt.toDate(),\r\n      } as Destination);\r\n    });\r\n    \r\n    // Sort by day first, then by orderIndex within each day\r\n    return destinations.sort((a, b) => {\r\n      if (a.day !== b.day) return a.day - b.day;\r\n      return a.orderIndex - b.orderIndex;\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching trip destinations:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Get destinations for a specific day of a trip\r\nexport async function getTripDestinationsByDay(tripId: string, day: number): Promise<Destination[]> {\r\n  try {\r\n    const q = query(\r\n      collection(db, DESTINATIONS_COLLECTION),\r\n      where('tripId', '==', tripId),\r\n      where('day', '==', day)\r\n    );\r\n    \r\n    const querySnapshot = await getDocs(q);\r\n    const destinations: Destination[] = [];\r\n    \r\n    querySnapshot.forEach((doc) => {\r\n      const data = doc.data();\r\n      destinations.push({\r\n        id: doc.id,\r\n        ...data,\r\n        createdAt: data.createdAt.toDate(),\r\n        updatedAt: data.updatedAt.toDate(),\r\n      } as Destination);\r\n    });\r\n    \r\n    // Sort by orderIndex within the day\r\n    return destinations.sort((a, b) => a.orderIndex - b.orderIndex);\r\n  } catch (error) {\r\n    console.error('Error fetching destinations by day:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Get a single destination by ID\r\nexport async function getDestination(destinationId: string): Promise<Destination | null> {\r\n  try {\r\n    const docRef = doc(db, DESTINATIONS_COLLECTION, destinationId);\r\n    const docSnap = await getDoc(docRef);\r\n    \r\n    if (docSnap.exists()) {\r\n      const data = docSnap.data();\r\n      return {\r\n        id: docSnap.id,\r\n        ...data,\r\n        createdAt: data.createdAt.toDate(),\r\n        updatedAt: data.updatedAt.toDate(),\r\n      } as Destination;\r\n    }\r\n    \r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error fetching destination:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Update a destination\r\nexport async function updateDestination(destinationId: string, updates: UpdateDestinationData): Promise<void> {\r\n  try {\r\n    const destinationRef = doc(db, DESTINATIONS_COLLECTION, destinationId);\r\n    const updateData = {\r\n      ...updates,\r\n      updatedAt: Timestamp.now(),\r\n    };\r\n    \r\n    await updateDoc(destinationRef, updateData);\r\n  } catch (error) {\r\n    console.error('Error updating destination:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Delete a destination\r\nexport async function deleteDestination(destinationId: string): Promise<void> {\r\n  try {\r\n    const destinationRef = doc(db, DESTINATIONS_COLLECTION, destinationId);\r\n    await deleteDoc(destinationRef);\r\n  } catch (error) {\r\n    console.error('Error deleting destination:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Reorder destinations within a day\r\nexport async function reorderDestinations(tripId: string, day: number, destinationIds: string[]): Promise<void> {\r\n  try {\r\n    const updatePromises = destinationIds.map((destinationId, index) => {\r\n      return updateDestination(destinationId, { orderIndex: index + 1 });\r\n    });\r\n    \r\n    await Promise.all(updatePromises);\r\n  } catch (error) {\r\n    console.error('Error reordering destinations:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Move destination to a different day\r\nexport async function moveDestinationToDay(\r\n  destinationId: string, \r\n  newDay: number, \r\n  newOrderIndex: number\r\n): Promise<void> {\r\n  try {\r\n    await updateDestination(destinationId, { \r\n      day: newDay, \r\n      orderIndex: newOrderIndex \r\n    });\r\n  } catch (error) {\r\n    console.error('Error moving destination to day:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Get next available order index for a day\r\nexport async function getNextOrderIndex(tripId: string, day: number): Promise<number> {\r\n  try {\r\n    const destinations = await getTripDestinationsByDay(tripId, day);\r\n    return destinations.length + 1;\r\n  } catch (error) {\r\n    console.error('Error getting next order index:', error);\r\n    return 1;\r\n  }\r\n}\r\n\r\n// Delete all destinations for a trip (used when deleting a trip)\r\nexport async function deleteAllTripDestinations(tripId: string): Promise<void> {\r\n  try {\r\n    const destinations = await getTripDestinations(tripId);\r\n    const deletePromises = destinations.map(destination => \r\n      deleteDestination(destination.id)\r\n    );\r\n    \r\n    await Promise.all(deletePromises);\r\n  } catch (error) {\r\n    console.error('Error deleting all trip destinations:', error);\r\n    throw error;\r\n  }\r\n} "
        }
    ]
}